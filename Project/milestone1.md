<table><tr><td> <em>Assignment: </em> It114 Milestone1</td></tr>
<tr><td> <em>Student: </em> Sai Chandra (sjc65)</td></tr>
<tr><td> <em>Generated: </em> 6/30/2023 6:18:40 PM</td></tr>
<tr><td> <em>Grading Link: </em> <a rel="noreferrer noopener" href="https://learn.ethereallab.app/homework/IT114-450-M23/it114-milestone1/grade/sjc65" target="_blank">Grading</a></td></tr></table>
<table><tr><td> <em>Instructions: </em> <ol><li>Create a new branch called Milestone1</li><li>At the root of your repository create a folder called Project if one doesn't exist yet</li><ol><li>You will be updating this folder with new code as you do milestones</li><li>You won't be creating separate folders for milestones; milestones are just branches</li></ol><li>Create a milestone1.md file inside the Project folder</li><li>Git add/commit/push it to Github (yes it'll be blank for now)</li><li>Create a pull request from Milestone1 to main (don't complete/merge it yet, just have it in open status)</li><li>Copy in the latest Socket sample code from the most recent Socket Part example of the lessons</li><ol><li>Recommended Part 5 (clients should be having names at this point and not ids)</li><li><a href="https://github.com/MattToegel/IT114/tree/Module5/Module5">https://github.com/MattToegel/IT114/tree/Module5/Module5</a>&nbsp;<br></li></ol><li>Fix the package references at the top of each file (these are the only edits you should do at this point)</li><li>Git add/commit the baseline</li><li>Ensure the sample is working and fill in the below deliverables</li><ol><li>Note: The client commands likely are different in part 5 with the /name and /connect options instead of just connect</li></ol><li>Get the markdown content or the file and paste it into the milestone1.md file or replace the file with the downloaded version</li><li>Git add/commit/push all changes</li><li>Complete the pull request merge from step 5</li><li>Locally checkout main</li><li>git pull origin main</li></ol></td></tr></table>
<table><tr><td> <em>Deliverable 1: </em> Startup </td></tr><tr><td><em>Status: </em> <img width="100" height="20" src="https://user-images.githubusercontent.com/54863474/211707773-e6aef7cb-d5b2-4053-bbb1-b09fc609041e.png"></td></tr>
<tr><td><table><tr><td> <em>Sub-Task 1: </em> Add screenshot showing your server being started and running</td></tr>
<tr><td><table><tr><td><img width="768px" src="https://firebasestorage.googleapis.com/v0/b/learn-e1de9.appspot.com/o/assignments%2Fsjc65%2F2023-06-30T18.50.09del1-task1.PNG.webp?alt=media&token=376690a4-70eb-46f0-b3c0-f194f7f986d6"/></td></tr>
<tr><td> <em>Caption:</em> <p>Server (on the left terminal) running and listening on port 3000<br></p>
</td></tr>
</table></td></tr>
<tr><td> <em>Sub-Task 2: </em> Add screenshot showing your client being started and running</td></tr>
<tr><td><table><tr><td><img width="768px" src="https://firebasestorage.googleapis.com/v0/b/learn-e1de9.appspot.com/o/assignments%2Fsjc65%2F2023-06-30T18.52.58del1-task2.PNG.webp?alt=media&token=5a2885f9-9c2a-4efd-ba83-9a0ad978179d"/></td></tr>
<tr><td> <em>Caption:</em> <p>Client (on the right terminal) connected to the server and waiting for input<br></p>
</td></tr>
</table></td></tr>
<tr><td> <em>Sub-Task 3: </em> Briefly explain the connection process</td></tr>
<tr><td> <em>Response:</em> <div>In the server-side connection, the server creates a port for clients to listen<br>on and then continuously waits and listens for a client to connect to<br>the socket. In the client-side connection, the client specifies the port's IP address<br>and port number and proceeds to connect to the socket. Once the client-server<br>connection is established, the client and server then can communicate with each other<br>by sending and receiving data. The socket steps are as follows, The server<br>creates a "serverSocket" object to specify what port the server is waiting on.<br>Then the server listens for incoming connections by entering a loop. Once a<br>client establishes a connection by specifying the server's IP address and port number,<br>the server stops looping its search for connections and waits for the client<br>to establish its connection. Once the connection is established, the client and server<br>are ready to communicate with each other via the "InputStream" and "OutputStream" objects.</div><br></td></tr>
</table></td></tr>
<table><tr><td> <em>Deliverable 2: </em> Sending/Receiving </td></tr><tr><td><em>Status: </em> <img width="100" height="20" src="https://user-images.githubusercontent.com/54863474/211707773-e6aef7cb-d5b2-4053-bbb1-b09fc609041e.png"></td></tr>
<tr><td><table><tr><td> <em>Sub-Task 1: </em> Add screenshot(s) showing evidence related to the checklist</td></tr>
<tr><td><table><tr><td><img width="768px" src="https://firebasestorage.googleapis.com/v0/b/learn-e1de9.appspot.com/o/assignments%2Fsjc65%2F2023-06-30T18.55.54del2-pic1.PNG.webp?alt=media&token=5b06e2d0-3c80-4b44-8400-a705245e8c76"/></td></tr>
<tr><td> <em>Caption:</em> <p>Two clients, Sai and Chandra (on the middle and the right terminals respectively),<br>are connected to the server and are successfully communicating with each other.<br></p>
</td></tr>
<tr><td><img width="768px" src="https://firebasestorage.googleapis.com/v0/b/learn-e1de9.appspot.com/o/assignments%2Fsjc65%2F2023-06-30T19.04.55del2-pic2.PNG.webp?alt=media&token=17f3217f-d4f4-4790-b445-66e532786ae9"/></td></tr>
<tr><td> <em>Caption:</em> <p>Sai and Chandra created two rooms, Skyrim and Morrowind, and the clients cannot<br>send or receive messages from each other.<br></p>
</td></tr>
</table></td></tr>
<tr><td> <em>Sub-Task 2: </em> Briefly explain how the messages are sent, broadcasted (sent to all connected clients), and received</td></tr>
<tr><td> <em>Response:</em> <p>From the client perspective on sending data, the client utilizes the &quot;OutputStream&quot; object<br>to send data to the server&#39;s socket. For the client to send text-based<br>messages, it utilizes the &quot;printWriter&quot; object to redirect text data from the output<br>stream to the &quot;printWriter&quot; object, which allows the text data to be sent<br>to the server as if using the &quot;print()&quot; method. The ServerThread allows the<br>server to handle multiple client connections on the same port, this allows multiple<br>clients to connect and send/receive data over the InputStream and OutputStream, displaying messages<br>sent from different clients to each other at the same time. From the<br>Room perspective when a room is created, the room keeps track of the<br>users in the room and uses the &quot;ServerThread&quot; object to broadcast messages to<br>only the clients that are in the specified room name, which allows users<br>to communicate independently from each other. From the client perspective on receiving messages,<br>the &quot;Payload&quot; class handles how the data is processed on the receiver&#39;s side.<br>The &quot;Payload&quot; class determines the attributes of who sent the message and the<br>status of the client&#39;s connection. For the most part, the &quot;Payload&quot; class&#39;s role<br>is to facilitate the packaging and transferring of data between the client and<br>server.<br></p><br></td></tr>
</table></td></tr>
<table><tr><td> <em>Deliverable 3: </em> Disconnecting / Terminating </td></tr><tr><td><em>Status: </em> <img width="100" height="20" src="https://user-images.githubusercontent.com/54863474/211707773-e6aef7cb-d5b2-4053-bbb1-b09fc609041e.png"></td></tr>
<tr><td><table><tr><td> <em>Sub-Task 1: </em> Add screenshot(s) showing evidence related to the checklist</td></tr>
<tr><td><table><tr><td><img width="768px" src="https://firebasestorage.googleapis.com/v0/b/learn-e1de9.appspot.com/o/assignments%2Fsjc65%2F2023-06-30T19.40.48del3-pic1.PNG.webp?alt=media&token=004766d2-17b8-407b-b83a-bb07b0bb5779"/></td></tr>
<tr><td> <em>Caption:</em> <p>Chandra&#39;s client (on the right terminal) disconnected from the server and notifies the<br>middle terminal of the disconnection. Also, the server continues to run and so<br>does Chandra&#39;s client<br></p>
</td></tr>
<tr><td><img width="768px" src="https://firebasestorage.googleapis.com/v0/b/learn-e1de9.appspot.com/o/assignments%2Fsjc65%2F2023-06-30T19.47.27del3-pic2.PNG.webp?alt=media&token=e1e805e1-24c4-4797-8fc0-9b91c2cc92dc"/></td></tr>
<tr><td> <em>Caption:</em> <p>The server (on the left terminal) was terminated but the clients (on the<br>middle and right terminals) are still active even though they are disconnected from<br>the server.<br></p>
</td></tr>
<tr><td><img width="768px" src="https://firebasestorage.googleapis.com/v0/b/learn-e1de9.appspot.com/o/assignments%2Fsjc65%2F2023-06-30T19.50.29del3-pic3.PNG.webp?alt=media&token=305837b7-4763-4c5a-87b0-b77cec3fb610"/></td></tr>
<tr><td> <em>Caption:</em> <p>The server was restarted and both clients were able to reconnect using only<br>the &quot;/connect localhost:3000&quot; command while still retaining the user names.<br></p>
</td></tr>
</table></td></tr>
<tr><td> <em>Sub-Task 2: </em> Briefly explain how the various disconnects/terminations are handled</td></tr>
<tr><td> <em>Response:</em> <p>When a client gets disconnected from the server socket, the client actively closes<br>the socket connection by calling the &quot;close()&quot; method on its socket object, specifically<br>when the user uses the &quot;/disconnect&quot; command to close the connection. The client<br>program doesn&#39;t crash because even though the clients will be unable to connect<br>to the server, the code continues to execute to search for new connections,<br>essentially keeping the client running until the user specifies a new port to<br>connect to. The server does not crash when a client disconnects because the<br>server cleans up any client threads that are hanging after a client disconnects<br>and it uses IOException handlers to allow the server to handle client disconnections.<br>Because the server can connect to any number of clients, the server continues<br>to listen for new connections even if all the clients disconnect from the<br>server.<br></p><br></td></tr>
</table></td></tr>
<table><tr><td> <em>Deliverable 4: </em> Misc </td></tr><tr><td><em>Status: </em> <img width="100" height="20" src="https://user-images.githubusercontent.com/54863474/211707773-e6aef7cb-d5b2-4053-bbb1-b09fc609041e.png"></td></tr>
<tr><td><table><tr><td> <em>Sub-Task 1: </em> Add the pull request for this branch</td></tr>
<tr><td> <a rel="noreferrer noopener" target="_blank" href="https://github.com/sjc65/sjc65-IT114-450/pull/5">https://github.com/sjc65/sjc65-IT114-450/pull/5</a> </td></tr>
<tr><td> <em>Sub-Task 2: </em> Talk about any issues or learnings during this assignment</td></tr>
<tr><td> <em>Response:</em> <p>I ran into several issues regarding the client commands. Originally the client commands<br>were very straightforward with &quot;kill server&quot; and &quot;quit&quot; but after new commands were<br>added and the format changed, I was having trouble with ending the connection<br>and killing the server without having to manually kill the terminals through VScode.<br>After looking at the notes, I realized that I could use &quot;/quit&quot; and<br>&quot;/disconnect&quot; to end the client connection. But I ran into another issue, by<br>using &quot;/quit&quot; the client connection would end by exiting the client itself and<br>not notifying the other connected clients in the process. So I learned that<br>using &quot;/disconnect&quot; is a far more optimal command since it notifies the other<br>users of the disconnection but also keeps the client running and capable of<br>reconnecting to the server again simply using the &quot;/connect&quot; command without having to<br>enter a new name.<br></p><br></td></tr>
</table></td></tr>
<table><tr><td><em>Grading Link: </em><a rel="noreferrer noopener" href="https://learn.ethereallab.app/homework/IT114-450-M23/it114-milestone1/grade/sjc65" target="_blank">Grading</a></td></tr></table>